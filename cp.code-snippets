{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
    "2-SAT": {
        "prefix": "2sat",
        "body": [
            "struct _2SAT{",
            "",
            "\tvector<vector<int>>g, gt;",
            "\tvector<bool>vis;",
            "\tvector<int>order, comp;",
            "\tvector<bool>val;",
            "\tint n;",
            "",
            "\t_2SAT(){};",
            "",
            "\t_2SAT(int sz){",
            "\t\tn = 2*sz+1;",
            "\t\tg.assign(n+1, {});",
            "\t\tgt.assign(n+1, {});",
            "\t}",
            "",
            "\tvoid add_edge(int u, int v){",
            "\t\tg[u].push_back(v);",
            "\t\tgt[v].push_back(u);",
            "\t}",
            "",
            "\tvoid add_OR(int a, int b){",
            "\t\ta <<= 1, b <<= 1;",
            "\t\tadd_edge(a^1, b);",
            "\t\tadd_edge(b^1, a);",
            "\t}",
            "\t",
            "\tvoid add_AND(int a, int b){",
            "\t\ta <<= 1, b <<= 1;",
            "\t\tadd_edge(a, b);",
            "\t\tadd_edge(b, a);",
            "\t}",
            "",
            "\tvoid add_XOR(int a, int b){",
            "\t\ta <<= 1, b <<= 1;",
            "\t\tadd_edge(a^1, b);",
            "\t\tadd_edge(b^1, a);",
            "\t\tadd_edge(a, b^1);",
            "\t\tadd_edge(b, a^1);",
            "\t}",
            "",
            "\tvoid add_XNOR(int a, int b){",
            "\t\ta <<= 1, b <<= 1;",
            "\t\tadd_edge(a, b);",
            "\t\tadd_edge(b, a);",
            "\t\tadd_edge(a^1, b^1);",
            "\t\tadd_edge(b^1, a^1);",
            "\t}",
            "",
            "\tvoid dfs(int u){",
            "\t\tvis[u] = 1;",
            "\t\tfor(int v : g[u]){",
            "\t\t\tif(!vis[v]) dfs(v);",
            "\t\t}",
            "\t\torder.push_back(u);",
            "\t}",
            "",
            "\tvoid dfs2(int u, int cur){",
            "\t\tcomp[u] = cur;",
            "\t\tfor(int v : gt[u]){",
            "\t\t\tif(!comp[v]) dfs2(v, cur);",
            "\t\t}",
            "\t}",
            "",
            "\tbool solve(){",
            "\t\tvis.assign(n+1, false);",
            "",
            "\t\tfor(int i=2; i<=n; i++){",
            "\t\t\tif(!vis[i]) dfs(i);",
            "\t\t}",
            "",
            "\t\treverse(order.begin(), order.end());",
            "\t\tcomp.assign(n+1, 0);",
            "\t\tint c = 0;",
            "",
            "\t\tfor(int x : order){",
            "\t\t\tif(!comp[x]) dfs2(x, ++c);",
            "\t\t}",
            "\t\tval.assign(n/2 + 1, false);",
            "\t\tfor(int i=1; i<=n/2; i++){",
            "\t\t\tif(comp[2*i] == comp[2*i+1]) return false;",
            "\t\t\tval[i] = comp[2*i] > comp[2*i+1];",
            "\t\t}",
            "\t\treturn true;",
            "",
            "\t}",
            "",
            "};"
        ]
    },
    "Aho-Corasick": {
        "prefix": "aho corasick",
        "body": [
            "int trie[M][K], link[M], elink[M], sz;",
            "int word[M];",
            "",
            "void add_string(string s){",
            "",
            "\tint node = 0;",
            "",
            "\tfor(char ch : s){",
            "\t\tint c = ch-'a';",
            "\t\tif(!trie[node][c]){",
            "\t\t\ttrie[node][c] = ++sz;",
            "\t\t}",
            "\t\tnode = trie[node][c];",
            "\t}",
            "",
            "\t//pattern \"s\" ends at vertex \"node\". store relevant pattern info in word[node].",
            "",
            "}",
            "",
            "void push_links(){",
            "",
            "\tqueue<int>q;",
            "\tq.push(0);",
            "",
            "\twhile(!q.empty()){",
            "\t\tint u = q.front();",
            "\t\tq.pop();",
            "\t\tfor(int c=0; c<K; c++){",
            "\t\t\tif(trie[u][c]){",
            "\t\t\t\tint v = trie[u][c];",
            "\t\t\t\tlink[v] = (trie[link[u]][c] == v) ? 0 : trie[link[u]][c];",
            "\t\t\t\telink[v] = (word[link[v]] > 0) ? link[v] : elink[link[v]];",
            "\t\t\t\tq.push(v);",
            "\t\t\t}else{",
            "\t\t\t\ttrie[u][c] = trie[link[u]][c];",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "}"
        ]
    },
    "Bellman Ford": {
        "prefix": "bellman ford",
        "body": [
            "const int M = 1e3 + 3, INF = 2e9;",
            "",
            "struct edge{",
            "\tint u, v, w;",
            "};",
            "",
            "edge e[M];",
            "int d[M], p[M], vis[M];",
            "vector<int>g[M];",
            "",
            "void dfs(int u){",
            "",
            "\td[u] = -INF;",
            "\tvis[u] = 1;",
            "",
            "\tfor(int x : g[u]){",
            "\t\tif(!vis[x]) dfs(x);",
            "\t}",
            "}",
            "",
            "void bellman_ford(int strt, int n, int m){",
            "",
            "\tfill(begin(d), end(d), INF);",
            "",
            "\td[strt] = 0;",
            "\tint x = -1;",
            "",
            "\tfor(int i=0; i<n; i++){",
            "\t\tfor(int j=0; j<m; j++){",
            "\t\t\tif(d[e[j].u] < INF and d[e[j].v] > d[e[j].u] + e[j].w){",
            "\t\t\t\td[e[j].v] = d[e[j].u] + e[j].w;",
            "\t\t\t\tp[e[j].v] = e[j].u;",
            "\t\t\t\tif(i == n-1) x = e[j].v;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tif(x != -1){",
            "\t\t//negative cycle found",
            "\t\tfor(int i=0; i<n; i++) x = p[x];",
            "\t\tdfs(x);",
            "\t}",
            "",
            "}"
        ]
    },
    "Bigmod": {
        "prefix": "bigmod",
        "body": [
            "ll expo(ll x, ll p){",
            "\tx %= MOD;",
            "\tif(p == -1) p = MOD-2;",
            "\tll res = 1;",
            "\twhile(p){",
            "\t\tif(p & 1) res = res * x % MOD;",
            "\t\tx = x * x % MOD;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            ""
        ]
    },
    "Binary Indexed Tree": {
        "prefix": "bit",
        "body": [
            "ll bit[M];",
            "int sz;",
            "",
            "void update(int idx, ll val){",
            "\twhile(idx <= sz){",
            "\t\tbit[idx] += val;",
            "\t\tidx += (idx & -idx);",
            "\t}",
            "}",
            "\t",
            "ll query(int R){",
            "\tll ret = 0;",
            "\twhile(R > 0){",
            "\t\tret += bit[R];",
            "\t\tR -= (R & -R);",
            "\t}",
            "\treturn ret;",
            "}",
            "",
            "ll query(int L, int R){",
            "\tif(L > R) return 0;",
            "\treturn query(R) - query(L-1);",
            "}"
        ]
    },
    "Centroid Decomposition": {
        "prefix": "centroid decomposition",
        "body": [
            "int sz[M], done[M], cpar[M], root;",
            "",
            "void go(int u, int p=-1){",
            "\tsz[u] = 1;",
            "\tfor(int v : g[u]){",
            "\t\tif(v == p or done[v]) continue;",
            "\t\tgo(v, u);",
            "\t\tsz[u] += sz[v];",
            "\t}",
            "}",
            "",
            "int find_centroid(int v, int p, int n){",
            "\tfor(int x : g[v]){",
            "\t\tif(x != p and !done[x] and sz[x] > n/2) return find_centroid(x, v, n);",
            "\t}",
            "\treturn v;",
            "}",
            "",
            "void decompose(int v, int p=-1){",
            "\tgo(v);",
            "\tint c = find_centroid(v, -1, sz[v]);",
            "\tif(p == -1) root = c;",
            "\tdone[c] = 1;",
            "\tcpar[c] = p;",
            "\tfor(int x : g[c]){",
            "\t\tif(!done[x]) decompose(x, c);",
            "\t}",
            "}",
            "",
            "void reset(int n){",
            "\tfor(int i=1; i<=n; i++){",
            "\t\tdone[i] = cpar[i] = sz[i] = 0;",
            "\t}",
            "}"
        ]
    },
    "Diameter of Tree": {
        "prefix": "diameter of tree",
        "body": [
            "vector<int>g[M];",
            "",
            "int diameter(){",
            "",
            "\tint mx = 0, node;",
            "",
            "\tfunction<void(int, int, int)>dfs = [&](int u, int p, int h){",
            "\t\tif(h >= mx){",
            "\t\t\tmx = h;",
            "\t\t\tnode = u;",
            "\t\t}",
            "\t\tfor(int v : g[u]){",
            "\t\t\tif(v != p) dfs(v, u, h+1);",
            "\t\t}",
            "\t};",
            "",
            "\tdfs(1, -1, 0);",
            "\tmx = 0;",
            "\tdfs(node, -1, 0);",
            "\treturn mx;",
            "",
            "}"
        ]
    },
    "Dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "vector<pll>g[M];",
            "ll d[M]; //initialize with INF",
            "",
            "void dijkstra(int src){",
            "",
            "\tfill(begin(d), end(d), INF);",
            "\td[src] = 0;",
            "\tpriority_queue<pll, vector<pll>, greater<pll>>pq;",
            "\tpq.emplace(0, src);",
            "",
            "\twhile(!pq.empty()){",
            "\t\tauto [cst, u] = pq.top();",
            "\t\tpq.pop();",
            "\t\tif(d[u] != cst) continue;",
            "\t\tfor(auto [v, weight] : g[u]){",
            "\t\t\tif(d[v] > d[u] + weight){",
            "\t\t\t\td[v] = d[u] + weight;",
            "\t\t\t\tpq.emplace(d[v], v);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "}",
            ""
        ]
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "int par[M], sz[M];",
            "",
            "void init(int n){ //run this",
            "\tfor(int i=1; i<=n; i++) par[i] = i, sz[i] = 1;",
            "}",
            "",
            "int Find(int u){",
            "\tif(u == par[u]) return u;",
            "\treturn par[u] = Find(par[u]);",
            "}",
            "",
            "void Union(int u, int v){",
            "",
            "\tu = Find(u), v = Find(v);",
            "",
            "\tif(u != v){",
            "\t\tif(sz[u] < sz[v]) swap(u, v);",
            "\t\tsz[u] += sz[v];",
            "\t\tpar[v] = u;",
            "\t}",
            "",
            "}"
        ]
    },
    "FFT": {
        "prefix": "fft",
        "body": [
            "//define N as a power of two greater than the size of any possible polynomial",
            "using cd = complex<double>;",
            "const double PI = acosl(-1);",
            "",
            "int rev[N]; cd w[N];",
            "static cd f[N];",
            "",
            "void prepare(int &n){",
            "\tint sz = __builtin_ctz(n);",
            "\tfor(int i=1; i<n; i++) rev[i] = (rev[i>>1] >> 1) | ((i & 1) << (sz - 1));",
            "\tw[0] = 0, w[1] = 1, sz = 1;",
            "\twhile(1 << sz < n){",
            "\t\tcd w_n = cd(cos(2*PI / (1<<(sz+1))), sin(2*PI / (1 << (sz+1))));",
            "\t\tfor(int i=1<<(sz-1); i<(1<<sz); i++){",
            "\t\t\tw[i<<1] = w[i], w[i<<1 | 1] = w[i] * w_n;",
            "\t\t}",
            "\t\tsz++;",
            "\t}",
            "}",
            "",
            "void fft(cd *a, int n){",
            "\tfor(int i=1; i<n-1; i++){",
            "\t\tif(i < rev[i]) swap(a[i], a[rev[i]]);",
            "\t}",
            "\tfor(int h=1; h<n; h<<=1){",
            "\t\tfor(int s=0; s<n; s+=h<<1){",
            "\t\t\tfor(int i=0; i<h; i++){",
            "\t\t\t\tcd &u = a[s+i], &v = a[s+i+h], t = v*w[h+i];",
            "\t\t\t\tv = u-t, u = u+t;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "",
            "vector<ll>multiply(vector<ll>a, vector<ll>b){",
            "\tint n = a.size(), m = b.size(), sz = 1;",
            "\tif(!n or !m) return {};",
            "\twhile(sz < n+m-1) sz <<= 1;",
            "\tprepare(sz);",
            "\tfor(int i=0; i<sz; i++) f[i] = cd(i < n ? a[i] : 0, i < m ? b[i] : 0);",
            "\tfft(f, sz);",
            "\tfor(int i=0; i<=(sz>>1); i++){",
            "\t\tint j = (sz - i) & (sz - 1);",
            "\t\tcd x = (f[i]*f[i] - conj(f[j]*f[j])) * cd(0, -0.25);",
            "\t\tf[j] = x, f[i] = conj(x);",
            "\t}",
            "\tfft(f, sz);",
            "\tvector<ll>c(n+m-1);",
            "\tfor(int i=0; i<n+m-1; i++) c[i] = round(f[i].real()/sz);",
            "\treturn c;",
            "}",
            ""
        ]
    },
    "GP Hash Table": {
        "prefix": "gp hash table",
        "body": [
            "struct chash{",
            "  const int RANDOM = (long long)(make_unique<char>().get())",
            "\t\t\t\t\t ^ chrono::high_resolution_clock::now()",
            "\t\t\t\t\t .time_since_epoch()",
            "\t\t\t\t\t .count();",
            "  static unsigned long long hash_f(unsigned long long x) {",
            "\tx += 0x9e3779b97f4a7c15;",
            "\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "\treturn x ^ (x >> 31);",
            "  }",
            "  static unsigned hash_combine(unsigned a, unsigned b) {",
            "\treturn a * 31 + b;",
            "  }",
            "  int operator()(int x) const { return hash_f(x) ^ RANDOM; }",
            "  int operator()(pair<int, int> x) const {",
            "\treturn hash_combine(x.first, x.second) ^ RANDOM;",
            "  }",
            "};",
            "gp_hash_table<int, int, chash>table;"
        ]
    },
    "Heavy-light decomposition": {
        "prefix": "hld",
        "body": [
            "//need LCA template to answer tree queries",
            "namespace HLD{",
            "\tint sub[M], par[M], depth[M];",
            "\tint head[M], chain[M], pos[M];",
            "\tint cur_pos, cur_chain;",
            "",
            "",
            "\tvoid dfs(int u, int p=0, int h=0){",
            "\t\tsub[u] = 1;",
            "\t\tpar[u] = p;",
            "\t\tdepth[u] = h;",
            "\t\tfor(auto v : g[u]){",
            "\t\t\tif(v != p){",
            "\t\t\t\tdfs(v, u, h+1);",
            "\t\t\t\tsub[u] += sub[v];",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid decompose(int u){",
            "\t\tint c = -1;",
            "\t\tfor(auto v : g[u]){",
            "\t\t\tif(v != par[u] and sub[v] >= sub[u]/2) c = v;",
            "\t\t}",
            "\t\t",
            "\t\tif(head[u] == 0){",
            "\t\t\thead[u] = u;",
            "\t\t\tchain[u] = ++cur_chain;",
            "\t\t}else{",
            "\t\t\tchain[u] = chain[head[u]];",
            "",
            "\t\t}",
            "\t\tpos[u] = ++cur_pos;",
            "\t\t//set value here",
            "\t\tif(c != -1){",
            "\t\t\thead[c] = head[u];",
            "\t\t\tdecompose(c);",
            "\t\t}",
            "\t\tfor(auto v : g[u]){",
            "\t\t\tif(v != par[u] and v != c){",
            "\t\t\t\tdecompose(v);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid HLD(int root, int n){",
            "\t\tcur_pos = cur_chain = 0;",
            "\t\tfor(int i=1; i<=n; i++){",
            "\t\t\tsub[i] = par[i] = depth[i] = head[i] = chain[i] = pos[i] = 0;",
            "\t\t}",
            "\t\tdfs(root);",
            "\t\tdecompose(root);",
            "\t}",
            "",
            "\tint anc_query(int u, int v){ //u is ancestor of v",
            "",
            "\t\tint ret = 0;",
            "\t\twhile(1){   ",
            "\t\t\tint L = pos[head[v]], R = pos[v];",
            "\t\t\tif(depth[u] >= depth[head[v]]){",
            "\t\t\t\t//include query(pos[u], R) if vertex values, query(pos[u]+1, R) if edge values",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\t//include query(L, R)",
            "\t\t\tv = par[head[v]];",
            "\t\t}",
            "\t\treturn ret;",
            "\t\t",
            "\t}",
            "",
            "\tint tree_query(int x, int y){",
            "\t\tint L = LCA::LCA(x, y);",
            "\t\tint ret;\t//combine anc_query(L, x) and (L, y);",
            "\t\treturn ret;",
            "\t}",
            "}"
        ]
    },
    "Hopcroft Karp": {
        "prefix": "hopcroft karp",
        "body": [
            "vector<int>g[M];",
            "int Lmatch[M], Rmatch[M], dist[M];",
            " ",
            "bool bfs(int n){",
            "\tqueue<int>q;",
            "\tfor(int u=1; u<=n; u++){",
            "\t\tif(Lmatch[u] == NIL) dist[u] = 0, q.push(u);",
            "\t\telse dist[u] = INF;",
            "\t}",
            "\tdist[NIL] = INF;",
            "\twhile(!q.empty()){",
            "\t\tint u = q.front();",
            "\t\tq.pop();",
            "\t\tif(dist[u] < dist[NIL]){",
            "\t\t\tfor(int v : g[u]){",
            "\t\t\t\tif(dist[Rmatch[v]] == INF){",
            "\t\t\t\t\tdist[Rmatch[v]] = dist[u] + 1;",
            "\t\t\t\t\tq.push(Rmatch[v]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn dist[NIL] != INF;",
            "}",
            " ",
            "bool dfs(int u){",
            "\tif(u == NIL) return true;",
            "\tfor(int v : g[u]){",
            "\t\tif(dist[Rmatch[v]] == dist[u] + 1 and dfs(Rmatch[v])){",
            "\t\t\tRmatch[v] = u;",
            "\t\t\tLmatch[u] = v;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t}",
            "\tdist[u] = INF;",
            "\treturn false;",
            "}",
            " ",
            "int HopcroftKarp(int n, int m){",
            "\tfill(Lmatch, Lmatch+n+1, 0);",
            "\tfill(Rmatch, Rmatch+m+1, 0);",
            "\tint res = 0;",
            "\twhile(bfs(n)){",
            "\t\tfor(int u=1; u<=n; u++){",
            "\t\t\tif(Lmatch[u]==NIL and dfs(u)) res++;",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "Hungarian": {
        "prefix": "hungarian",
        "body": [
            "/*returns maximum/minimum weighted bipartite matching. Complexity : O(N^2 * M)",
            "flag = -1 minimizes, flag = 1 maximizes. */",
            "#define CLR(a) memset(a, 0, sizeof a)",
            "",
            "ll weight[N][M];",
            "int used[M], P[M], way[M], match[M];",
            "ll U[M], V[M], minv[M], ara[N][M];",
            "",
            "ll hungarian(int n, int m, int flag){",
            "\tCLR(U), CLR(V), CLR(P), CLR(ara), CLR(way);",
            "\tfor(int i=1; i<=n; i++){",
            "\t\tfor(int j=1; j<=m; j++){",
            "\t\t\tara[i][j] = -flag * weight[i][j];",
            "\t\t}",
            "\t}",
            "",
            "\tif(n > m) m = n;",
            "\tint a, b, d;",
            "\tll r, w;",
            "\tfor(int i=1; i<=n; i++){",
            "\t\tP[0] = i, b = 0;",
            "\t\tfor(int j=0; j<=m; j++) minv[j] = INF, used[j] = false;",
            "\t\tdo{",
            "\t\t\tused[b] = true;",
            "\t\t\ta = P[b], d = 0, w = INF;",
            "\t\t\tfor(int j=1; j<=m; j++){",
            "\t\t\t\tif(!used[j]){",
            "\t\t\t\t\tr = ara[a][j] - U[a] - V[j];",
            "\t\t\t\t\tif(r < minv[j]) minv[j] = r, way[j] = b;",
            "\t\t\t\t\tif(minv[j] < w) w = minv[j], d = j;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tfor(int j=0; j<=m; j++){",
            "\t\t\t\tif(used[j]) U[P[j]] += w, V[j] -= w;",
            "\t\t\t\telse minv[j] -= w;",
            "\t\t\t}",
            "\t\t\tb = d;",
            "\t\t}while(P[b] != 0);",
            "\t\tdo{",
            "\t\t\td = way[b];",
            "\t\t\tP[b] = P[d], b = d;",
            "\t\t}while(b != 0);",
            "\t}",
            "\tfor(int j=1; j<=m; j++) match[P[j]] = j;",
            "\treturn flag*V[0];",
            "",
            "}"
        ]
    },
    "LCA (Binary Lifting)": {
        "prefix": "lca",
        "body": [
            "namespace LCA{",
            "\tint d[M], up[M][K];",
            "\tint tin[M], tout[M], timer;",
            "",
            "\tvoid dfs(int u, int par, int h=0){",
            "",
            "\t\tup[u][0] = par;",
            "\t\td[u] = h;",
            "\t\ttin[u] = ++timer;",
            "",
            "",
            "\t\tfor(int i=1; i<K; i++){",
            "\t\t\tup[u][i] = up[up[u][i-1]][i-1];",
            "\t\t}",
            "",
            "\t\tfor(int v : g[u]){",
            "\t\t\tif(v != par) dfs(v, u, h+1);",
            "\t\t}",
            "",
            "\t\ttout[u] = ++timer;",
            "",
            "\t}",
            "",
            "\tbool is_ancestor(int u, int v){",
            "\t\treturn tin[u] <= tin[v] and tout[u] >= tout[v];",
            "\t}",
            "",
            "",
            "\tint LCA(int u, int v){",
            "",
            "\t\tif(is_ancestor(u, v)) return u;",
            "\t\tif(is_ancestor(v, u)) return v;",
            "",
            "\t\tfor(int i=K-1; i>=0; i--){",
            "\t\t\tif(!is_ancestor(up[u][i], v)) u = up[u][i];",
            "\t\t}",
            "\t\treturn up[u][0];",
            "\t}",
            "",
            "\tint dist(int u, int v){",
            "\t\treturn d[u] + d[v] - 2*d[LCA(u, v)];",
            "\t}",
            "",
            "",
            "\tvoid preprocess(int root, int n){ //run this first",
            "\t\tfor(int i=0; i<=n; i++){",
            "\t\t\td[i] = tin[i] = tout[i] = 0;",
            "\t\t\tmemset(up[i], sizeof up[i], 0);",
            "\t\t}",
            "\t\ttimer = 0;",
            "\t\tdfs(root, root);",
            "\t}",
            "}",
            ""
        ]
    },
    "Matrix Exponentiation": {
        "prefix": "matexpo",
        "body": [
            "// Complexity : O(n^3 log p). define M and MOD",
            "const int M = 103;",
            "const int MOD = 998244353;",
            "",
            "struct matrix{",
            "\tint mat[M][M];",
            "\tint n, m;",
            "\tmatrix(){};",
            "\tmatrix(int _n, int _m=0) : n(_n), m(_m){",
            "\t\tif(!m) m = n;",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tfor(int j=0; j<m; j++){",
            "\t\t\t\tmat[i][j] = 0;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tmatrix operator *(const matrix &mul){",
            "\t\tint p = n, q = mul.n, r = mul.m;",
            "\t\tmatrix ret(p, r);",
            "\t\tfor(int i=0; i<p; i++){",
            "\t\t\tfor(int j=0; j<r; j++){",
            "\t\t\t\tfor(int k=0; k<q; k++){",
            "\t\t\t\t\tret.mat[i][j] += 1LL * mat[i][k] * mul.mat[k][j] % MOD;",
            "\t\t\t\t\tret.mat[i][j] %= MOD;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "\t",
            "};",
            "",
            "matrix expo(matrix m, ll p){",
            "\tint n = m.n;",
            "\tmatrix ret(n);",
            "\tfor(int i=0; i<n; i++) ret.mat[i][i] = 1;",
            "\twhile(p){",
            "\t\tif(p & 1) ret = ret * m;",
            "\t\tm = m * m;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn ret;",
            "}"
        ]
    },
    "Maxflow (Dinic)": {
        "prefix": "maxflow",
        "body": [
            "struct edge{",
            "\tint u, v;",
            "\tll cap, flow = 0;",
            "};",
            " ",
            "struct Dinic{",
            "\tvector<edge>edges;",
            "\tvector<vector<int>>adj;",
            "\tint n, m = 0;",
            "\tint s, t;",
            "\tvector<int>lv, ptr;",
            "\tqueue<int>q;",
            " ",
            "\tDinic(int n, int s, int t) : n(n), s(s), t(t){",
            "\t\tadj.resize(n);",
            "\t\tlv.resize(n);",
            "\t\tptr.resize(n);",
            "\t}",
            " ",
            "\tvoid add_edge(int u, int v, ll cap){",
            "\t\tedges.emplace_back(u, v, cap);",
            "\t\tedges.emplace_back(v, u, 0);",
            "\t\tadj[u].push_back(m);",
            "\t\tadj[v].push_back(m+1);",
            "\t\tm += 2;",
            "\t}",
            " ",
            "\tbool bfs(){",
            "\t\twhile(!q.empty()){",
            "\t\t\tint u = q.front();",
            "\t\t\tq.pop();",
            "\t\t\tfor(int id : adj[u]){",
            "\t\t\t\tif(edges[id].cap - edges[id].flow < 1) continue;",
            "\t\t\t\tif(lv[edges[id].v] != -1) continue;",
            "\t\t\t\tlv[edges[id].v] = lv[u] + 1;",
            "\t\t\t\tq.push(edges[id].v);",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn lv[t] != -1;",
            "\t}",
            " ",
            "\tll dfs(int u, ll pushed){",
            "\t\tif(pushed == 0) return 0;",
            "\t\tif(u == t) return pushed;",
            "\t\tfor(int &cid=ptr[u]; cid<(int)adj[u].size(); cid++){",
            "\t\t\tint id = adj[u][cid];",
            "\t\t\tint v = edges[id].v;",
            "\t\t\tif(lv[u] + 1 != lv[v] or edges[id].cap - edges[id].flow < 1) continue;",
            "\t\t\tll tr = dfs(v, min(pushed, edges[id].cap - edges[id].flow));",
            "\t\t\tif(tr == 0) continue;",
            "\t\t\tedges[id].flow += tr;",
            "\t\t\tedges[id^1].flow -= tr;",
            "\t\t\treturn tr;",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            " ",
            "\tll maxflow(){",
            "\t\tll f = 0;",
            "\t\twhile(1){",
            "\t\t\tfill(lv.begin(), lv.end(), -1);",
            "\t\t\tlv[s] = 0;",
            "\t\t\tq.push(s);",
            "\t\t\tif(!bfs()) break;",
            "\t\t\tfill(ptr.begin(), ptr.end(), 0);",
            "\t\t\twhile(ll pushed = dfs(s, INF)){",
            "\t\t\t\tf += pushed;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn f;",
            "\t}",
            "\tvector<int>mincut(){",
            "\t\tqueue<int>q;",
            "\t\tvector<int>vis(n+1, 0), ret;",
            "\t\tq.push(s), ret.push_back(s);",
            "\t\tvis[s] = 1;",
            "\t\twhile(!q.empty()){",
            "\t\t\tint u = q.front();",
            "\t\t\tq.pop();",
            "\t\t\tfor(int id : adj[u]){",
            "\t\t\t\tif(edges[id].cap - edges[id].flow > 0 and !vis[edges[id].v]){",
            "\t\t\t\t\tq.push(edges[id].v);",
            "\t\t\t\t\tret.push_back(edges[id].v);",
            "\t\t\t\t\tvis[edges[id].v] = 1;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "};"
        ]
    },
    "Merge Sort Tree": {
        "prefix": "merge sort tree",
        "body": [
            "struct node{",
            "",
            "\tvector<int>vc;",
            "",
            "\tnode(int x = 0){",
            "\t\tif(x) vc.push_back(x);",
            "\t}",
            "",
            "\tnode operator+(const node &other){",
            "\t\tnode ret;",
            "\t\tret.vc = vc;",
            "\t\tfor(int x : other.vc) ret.vc.push_back(x);",
            "\t\tsort(ret.vc.begin(), ret.vc.end());",
            "\t\treturn ret;",
            "\t}",
            "",
            "",
            "};",
            "",
            "node t[4*M];",
            "",
            "",
            "void build(int a[], int v, int tl, int tr){",
            "",
            "\tif(tl == tr){",
            "\t\tt[v] = node(a[tl]);",
            "\t\treturn;",
            "\t}",
            "",
            "\tint tm = (tl + tr) / 2;",
            "\tbuild(a, v*2, tl, tm);",
            "\tbuild(a, v*2+1, tm+1, tr);",
            "\tt[v] = t[v*2] + t[v*2+1];",
            "}",
            "",
            "int query(int v, int tl, int tr, int l, int r, int x){",
            "",
            "\tif(l > tr or r < tl) return 0;",
            "",
            "\tif(l <= tl and tr <= r){",
            "\t\tint ret;",
            "\t\t//do your thing with x here",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tint tm = (tl + tr) / 2;",
            "",
            "\tint Lchild = query(v*2, tl, tm, l, r, x);",
            "\tint Rchild = query(v*2+1, tm+1, tr, l, r, x);",
            "",
            "\treturn Lchild + Rchild;",
            "",
            "}"
        ]
    },
    "Min cost (fixed) flow": {
        "prefix": "min cost flow",
        "body": [
            "struct edge{",
            "\tint from, to;",
            "\tll capacity, cost;",
            "};",
            " ",
            "vector<vector<int>>adj;",
            "vector<vector<ll>>cost, capacity;",
            " ",
            "void SPFA(int n, int v0, vector<ll>&d, vector<int>&p){",
            "\td.assign(n, INF);",
            "\td[v0] = 0;",
            "\tvector<bool>inq(n, false);",
            "\tqueue<int>q;",
            "\tq.push(v0);",
            "\tp.assign(n, -1);",
            " ",
            "\twhile(!q.empty()){",
            "\t\tint u = q.front();",
            "\t\tq.pop();",
            "\t\tinq[u] = false;",
            "\t\tfor(int v : adj[u]){",
            "\t\t\tif(capacity[u][v] > 0 && d[v] > d[u] + cost[u][v]){",
            "\t\t\t\td[v] = d[u] + cost[u][v];",
            "\t\t\t\tp[v] = u;",
            "\t\t\t\tif(!inq[v]){",
            "\t\t\t\t\tinq[v] = true;",
            "\t\t\t\t\tq.push(v);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            " ",
            "ll min_cost_flow(int N, vector<edge>edges, ll F, int s, int t) {",
            "\tadj.assign(N, vector<int>());",
            "\tcost.assign(N, vector<ll>(N, 0));",
            "\tcapacity.assign(N, vector<ll>(N, 0));",
            "\tfor(edge e : edges) {",
            "\t\tadj[e.from].push_back(e.to);",
            "\t\tadj[e.to].push_back(e.from);",
            "\t\tcost[e.from][e.to] = e.cost;",
            "\t\tcost[e.to][e.from] = -e.cost;",
            "\t\tcapacity[e.from][e.to] = e.capacity;",
            "\t}",
            " ",
            "\tll flow = 0, cost = 0;",
            "\tvector<ll>d;",
            "\tvector<int>p;",
            "\twhile(flow < F){",
            "\t\tSPFA(N, s, d, p);",
            "\t\tif(d[t] == INF) break;",
            "\t\t// find max flow on that path",
            "\t\tll f = F - flow;",
            "\t\tint cur = t;",
            "\t\twhile(cur != s){",
            "\t\t\tf = min(f, capacity[p[cur]][cur]);",
            "\t\t\tcur = p[cur];",
            "\t\t}",
            " ",
            "\t\t// apply flow",
            "\t\tflow += f;",
            "\t\tcost += f * d[t];",
            "\t\tcur = t;",
            "\t\twhile(cur != s){",
            "\t\t\tcapacity[p[cur]][cur] -= f;",
            "\t\t\tcapacity[cur][p[cur]] += f;",
            "\t\t\tcur = p[cur];",
            "\t\t}",
            "\t}",
            " ",
            "\tif(flow < F) return -1;",
            "\telse return cost;",
            "}"
        ]
    },
    "Min cost max flow": {
        "prefix": "mcmf",
        "body": [
            "struct edge{",
            "\tint v, rev_pos;",
            "\tll cap, cost, flow = 0;",
            "};",
            "",
            "struct MCMF{",
            "\t",
            "\tint n, s, t;",
            "\tvector<vector<edge>>E;",
            "",
            "\tvector<int>vis, par, pos;",
            "\tvector<ll>caps, dist;",
            "",
            "\tMCMF(int n, int s, int t) : n(n), s(s), t(t), E(n), vis(n), par(n), pos(n), caps(n), dist(n){}",
            "",
            "\tinline void add_edge(int u, int v, ll cap, ll cost = 0){",
            "\t\tE[u].emplace_back(v, E[v].size(), cap, cost);",
            "\t\tE[v].emplace_back(u, E[u].size() - 1, 0, -cost);",
            "\t}",
            "",
            "\tbool SPFA(){",
            "\t\tvis.assign(n, 0);",
            "\t\tfor(int i=0; i<n; i++) caps[i] = dist[i] = INF;",
            "\t\tqueue<int>q;",
            "\t\tq.emplace(s), dist[s] = 0, vis[s] = 1;",
            "\t\twhile(!q.empty()){",
            "\t\t\tint i = 0, u = q.front();",
            "\t\t\tq.pop(), vis[u] = 0;",
            "\t\t\tfor(auto &e : E[u]){",
            "\t\t\t\tint v = e.v;",
            "\t\t\t\tll f = e.cap - e.flow, w = dist[u] + e.cost;",
            "\t\t\t\tif(f > 0 and dist[v] > w){",
            "\t\t\t\t\tdist[v] = w, par[v] = u, pos[v] = i;",
            "\t\t\t\t\tcaps[v] = min(caps[u], f);",
            "\t\t\t\t\tif(!vis[v]){",
            "\t\t\t\t\t\tq.push(v), vis[v] = 1;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\t++i;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn dist[t] != INF;",
            "\t}",
            "",
            "\tpll maxflow(){",
            "\t\tll flow = 0, cost = 0;",
            "\t\twhile(SPFA()){",
            "\t\t\tint v = t;",
            "\t\t\tll f = caps[v];",
            "\t\t\tflow += f;",
            "\t\t\twhile(v ^ s){",
            "\t\t\t\tint u = par[v];",
            "\t\t\t\tedge &e = E[u][pos[v]];",
            "\t\t\t\te.flow += f;",
            "\t\t\t\tE[v][e.rev_pos].flow -= f;",
            "\t\t\t\tv = u;",
            "\t\t\t}",
            "\t\t\tcost += dist[t] * f;",
            "\t\t}",
            "\t\treturn make_pair(flow, cost);",
            "\t}",
            "};"
        ]
    },
    "Modulo arithmetic": {
        "prefix": "mod",
        "body": [
            "struct mint{",
            "  int value;",
            "  static const int MOD_value = MOD;",
            "",
            "  mint(long long v = 0){ value = v % MOD; if(value < 0) value += MOD;}",
            "  mint(long long a, long long b) : value(0){ *this += a; *this /= b;}",
            "",
            "  mint& operator+=(mint const& b){value += b.value; if (value >= MOD) value -= MOD; return *this;}",
            "  mint& operator-=(mint const& b){value -= b.value; if (value < 0) value += MOD;return *this;}",
            "  mint& operator*=(mint const& b){value = (long long)value * b.value % MOD;return *this;}",
            "",
            "  friend mint expo(mint a, long long e){",
            "\tmint res = 1; while (e){ if (e&1) res *= a; a *= a; e >>= 1; }",
            "\treturn res;",
            "  }",
            "  friend mint inverse(mint a){ return expo(a, MOD - 2); }",
            "",
            "  mint& operator/=(mint const& b){ return *this *= inverse(b); }",
            "  friend mint operator+(mint a, mint const b){ return a += b; }",
            "  friend mint operator-(mint a, mint const b){ return a -= b; }",
            "  friend mint operator-(mint const a){ return 0 - a; }",
            "  friend mint operator*(mint a, mint const b){ return a *= b; }",
            "  friend mint operator/(mint a, mint const b){ return a /= b; }",
            "  friend istream& operator>>(istream& is, mint& a){ return is >> a.value;}",
            "  friend ostream& operator<<(ostream& os, mint const& a){ return os << a.value;}",
            "  friend bool operator==(mint const& a, mint const& b){ return a.value == b.value;}",
            "  friend bool operator!=(mint const& a, mint const& b){ return a.value != b.value;}",
            "};",
            "",
            "mint expo(ll a, long long e){",
            "\treturn expo((mint)a, e);",
            "}",
            "",
            "mint fact[M], invfact[M];",
            "",
            "void precalc(){ //run this first",
            "\tfact[0] = 1;",
            "\tfor(int i=1; i<M; i++) fact[i] = i*fact[i-1];",
            "\tinvfact[M-1] = 1/fact[M-1];",
            "\tfor(int i=M-2; i>=0; i--) invfact[i] = (i+1)*invfact[i+1];",
            "}",
            "",
            "mint nCr(int n, int r){",
            "\tif(r > n or r < 0) return 0;",
            "\treturn fact[n] * invfact[r] * invfact[n-r];",
            "}  "
        ]
    },
    "nCr": {
        "prefix": "ncr",
        "body": [
            "ll fact[M], invfact[M];",
            "",
            "ll expo(ll x, ll p){",
            "\tx %= MOD;",
            "\tll res = 1;",
            "\tif(p == -1) p = MOD-2;",
            "\twhile(p){",
            "\t\tif(p & 1) res = res * x % MOD;",
            "\t\tx = x * x % MOD;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "void precalc(){ //run this first",
            "\tfact[0] = 1;",
            "\tfor(int i=1; i<M; i++) fact[i] = i*fact[i-1] % MOD;",
            "\tinvfact[M-1] = expo(fact[M-1], -1);",
            "\tfor(int i=M-2; i>=0; i--) invfact[i] = (i+1)*invfact[i+1] % MOD;",
            "}",
            "",
            "ll nCr(int n, int r){",
            "\tif(r > n or r < 0) return 0LL;",
            "\treturn (fact[n] * invfact[r] % MOD) * invfact[n-r] % MOD;",
            "}  ",
            ""
        ]
    },
    "Ordered Set": {
        "prefix": "ordered set",
        "body": [
            "using namespace __gnu_pbds;",
            "",
            "typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>ordered_set; \t",
            ""
        ]
    },
    "Compressed Virtual Tree": {
        "prefix": "virtual tree",
        "body": [
            "int used[M], tpar[M];",
            "vector<int>gt[M];",
            "int rut;",
            "vector<int>nodes;",
            "",
            "void gen_tree(vector<int>vc){",
            "\t",
            "\tfor(int x : vc) used[x] = 1;",
            "\tsort(vc.begin(), vc.end(), [&](int x, int y){",
            "\t\treturn tin[x] < tin[y];",
            "\t});",
            "\t",
            "\tnodes = vc;",
            "\tfor(int i=0; i+1<vc.size(); i++){",
            "\t\tint L = LCA(vc[i], vc[i+1]);",
            "\t\tif(!used[L]) nodes.push_back(L), used[L] = 1;",
            "\t}",
            "",
            "\tsort(nodes.begin(), nodes.end(), [&](int x, int y){",
            "\t\treturn tin[x] < tin[y];",
            "\t});",
            "",
            "\tvector<int>cur;",
            "",
            "\tfor(int x : nodes){",
            "\t\twhile(!cur.empty() and LCA(x, cur.back()) != cur.back()){",
            "\t\t\ttpar[cur.back()] = cur[cur.size()-2];",
            "\t\t\tcur.pop_back();",
            "\t\t}",
            "\t\tcur.push_back(x);",
            "\t}",
            "",
            "\twhile(cur.size() > 1){",
            "\t\ttpar[cur.back()] = cur[cur.size()-2];",
            "\t\tcur.pop_back();",
            "\t}",
            "",
            "\tfor(int x : nodes){",
            "\t\tif(tpar[x]) gt[tpar[x]].push_back(x);",
            "\t\telse rut = x;",
            "\t}",
            "",
            "}",
            "",
            "",
            "void reset(){",
            "\tfor(int x : nodes){",
            "\t\tused[x] = tpar[x] = 0;",
            "\t\tgt[x].clear();",
            "\t}",
            "\trut = 0;",
            "\tnodes.clear();",
            "}",
            ""
        ]
    },
    "Prefix function": {
        "prefix": "prefix function",
        "body": [
            "vector<int>prefix_function(string s){",
            "",
            "\tint n = s.size();",
            "\tvector<int>pi(n, 0);",
            "",
            "\tfor(int i=1; i<n; i++){",
            "\t\tint j = pi[i-1];",
            "\t\twhile(j>0 and s[i] != s[j]) j = pi[j-1];",
            "\t\tif(s[i] == s[j]) j++;",
            "\t\tpi[i] = j;",
            "\t}",
            "",
            "\treturn pi;",
            "",
            "}",
            ""
        ]
    },
    "SCC": {
        "prefix": "scc",
        "body": [
            "namespace SCC{",
            "",
            "\tvector<int>g[M], gr[M], gc[M];",
            "\tint vis[M], id[M], sz[M];",
            "\tvector<int>order, comp, roots;",
            "",
            "\tvoid addEdge(int u, int v){",
            "\t\tg[u].push_back(v), gr[v].push_back(u);",
            "\t}",
            "",
            "\tvoid dfs1(int u){",
            "\t\tvis[u] = 1;",
            "\t\tfor(int x : g[u]){",
            "\t\t\tif(!vis[x]) dfs1(x);",
            "\t\t}",
            "\t\torder.push_back(u);",
            "\t}",
            "",
            "\tvoid dfs2(int u){",
            "\t\tvis[u] = 1;",
            "\t\tcomp.push_back(u);",
            "\t\tfor(int x : gr[u]){",
            "\t\t\tif(!vis[x]) dfs2(x);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid condense(int n){",
            "\t\tfill(vis, vis+n+1, 0);",
            "\t\tfor(int i=1; i<=n; i++){",
            "\t\t\tif(!vis[i]) dfs1(i);",
            "\t\t}",
            "\t\treverse(order.begin(), order.end());",
            "\t\tfill(vis, vis+n+1, 0);",
            "\t\tfor(int u : order){",
            "\t\t\tif(!vis[u]){",
            "\t\t\t\tdfs2(u); //this part of the code processes components, returns them in comp",
            "\t\t\t\tfor(int v : comp) id[v] = u;",
            "\t\t\t\tsz[u] = (int)comp.size();",
            "\t\t\t\troots.push_back(u);",
            "\t\t\t\tcomp.clear();",
            "\t\t\t}",
            "\t\t}",
            "\t\tfill(vis, vis+n+1, 0);",
            "\t\tfor(int u=1; u<=n; u++){",
            "\t\t\tfor(int v : g[u]){",
            "\t\t\t\tif(id[u] != id[v]){",
            "\t\t\t\t\tgc[id[u]].push_back(id[v]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid reset(int n){",
            "\t\torder.clear(), comp.clear(), roots.clear();",
            "\t\tfor(int i=1; i<=n; i++){",
            "\t\t\tg[i].clear(), gr[i].clear(), gc[i].clear();",
            "\t\t\tid[i] = vis[i] = sz[i] = 0;",
            "\t\t}",
            "\t}",
            "",
            "}",
            ""
        ]
    },
    "Segment Tree": {
        "prefix": "segtree",
        "body": [
            "struct segtree{",
            "",
            "\tT t[4*M];",
            "\tint n;",
            "",
            "\tsegtree(int n=0) : n(n){}",
            "",
            "\tvoid build(int a[], int v, int tl, int tr){",
            "",
            "\t\tif(tl == tr){",
            "\t\t\tt[v] = T(a[tl]);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tbuild(a, v*2, tl, tm);",
            "\t\tbuild(a, v*2+1, tm+1, tr);",
            "\t\tt[v] = t[v*2] + t[v*2+1];",
            "\t}",
            "",
            "\tvoid build(int a[]){",
            "\t\tbuild(a, 1, 1, n);",
            "\t}",
            "",
            "\tvoid update(int v, int tl, int tr, int pos, int val){",
            "",
            "\t\tif(tl == tr){",
            "\t\t\tt[v] = T(val);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tif(pos <= tm) update(v*2, tl, tm, pos, val);",
            "\t\telse update(v*2+1, tm+1, tr, pos, val);",
            "\t\tt[v] = t[v*2] + t[v*2+1];",
            "",
            "\t}",
            "",
            "\tvoid update(int idx, int val){",
            "\t\tupdate(1, 1, n, idx, val);",
            "\t}",
            "",
            "\tT query(int v, int tl, int tr, int l, int r){",
            "",
            "\t\tif(l > tr or r < tl) return T(0);",
            "",
            "\t\tif(l <= tl and tr <= r) return t[v];",
            "",
            "\t\tint tm = (tl + tr) / 2;",
            "",
            "\t\tT Lchild = query(v*2, tl, tm, l, r);",
            "\t\tT Rchild = query(v*2+1, tm+1, tr, l, r);",
            "",
            "\t\treturn Lchild + Rchild;",
            "",
            "\t}",
            "",
            "\tT query(int L, int R){",
            "\t\treturn query(1, 1, n, L, R);",
            "\t}",
            "};"
        ]
    },
    "Segment Tree Lazy Propogation": {
        "prefix": "lazy segtree",
        "body": [
            "struct segtree_lazy{",
            "\t",
            "\tll t[4*M], lazy[4*M];",
            "\tint n;",
            "",
            "\tsegtree_lazy(int n=0) : n(n){};",
            "",
            "\tvoid build(ll a[], int v, int tl, int tr){",
            "",
            "\t\t//lazy[v] = -1; //for assignment",
            "\t\tif(tl == tr){",
            "\t\t\tt[v] = a[tl];",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tbuild(a, v*2, tl, tm);",
            "\t\tbuild(a, v*2+1, tm+1, tr);",
            "\t\tt[v] = max(t[v*2], t[v*2+1]);",
            "\t}",
            "",
            "\tvoid build(ll a[]){",
            "\t\tbuild(a, 1, 1, n);",
            "\t}",
            "",
            "\tvoid push(int v, int tl, int tr){",
            "",
            "\t\t//if(lazy[v] == -1) return; //for assignment",
            "\t\tt[v] += lazy[v];",
            "\t\tif(tl != tr){",
            "\t\t\tlazy[v*2] += lazy[v];",
            "\t\t\tlazy[v*2+1] += lazy[v];",
            "\t\t}",
            "\t\tlazy[v] = 0;",
            "",
            "\t}",
            "",
            "\tvoid update(int v, int tl, int tr, int l, int r, ll val){",
            "",
            "\t\tpush(v, tl, tr);",
            "",
            "\t\tif(l > tr or r < tl) return;",
            "",
            "\t\tif(l <= tl and tr <= r){",
            "\t\t\tlazy[v] += val;",
            "\t\t\tpush(v, tl, tr);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tint tm = (tl + tr) / 2;",
            "\t\tupdate(v*2, tl, tm, l, r, val);",
            "\t\tupdate(v*2+1, tm+1, tr, l, r, val);",
            "\t\tt[v] = max(t[v*2], t[v*2+1]);",
            "",
            "\t}",
            "",
            "\tvoid update(int l, int r, ll val){",
            "\t\tupdate(1, 1, n, l, r, val);",
            "\t}",
            "",
            "\tll query(int v, int tl, int tr, int l, int r){",
            "",
            "\t\tpush(v, tl, tr);",
            "",
            "\t\tif(l > tr or r < tl) return 0;",
            "",
            "\t\tif(l <= tl and tr <= r) return t[v];",
            "",
            "\t\tint tm = (tl + tr) / 2;",
            "",
            "\t\tll Lchild = query(v*2, tl, tm, l, r);",
            "\t\tll Rchild = query(v*2+1, tm+1, tr, l, r);",
            "",
            "\t\treturn max(Lchild, Rchild);",
            "",
            "\t}",
            "",
            "\tll query(int l, int r){",
            "\t\treturn query(1, 1, n, l, r);",
            "\t}",
            "};"
        ]
    },
    "Sieve, Prime factorization": {
        "prefix": "prime factorization",
        "body": [
            "int sp[M];",
            "vector<int>pr;",
            "",
            "void sieve(){",
            "",
            "\tfor(int i=2; i<M; i++){",
            "\t\tif(!sp[i]){",
            "\t\t\tsp[i] = i;",
            "\t\t\tpr.push_back(i);",
            "\t\t}",
            "\t\tfor(int j=0; j<pr.size() and pr[j]<=sp[i] and i*pr[j]<M; j++){",
            "\t\t\tsp[i*pr[j]] = pr[j];",
            "\t\t}",
            "\t}",
            "}",
            "",
            "void factorize(int x){",
            "",
            "\twhile(x > 1){",
            "\t\t//sp[x] is a prime factor",
            "\t\tx /= sp[x];",
            "\t}",
            "",
            "}"
        ]
    },
    "Sparse Table": {
        "prefix": "sparse table",
        "body": [
            "int lg2[M];",
            "int table[M][K];",
            "",
            "void precalc(){ //run this first",
            "",
            "\tfor(int i=2; i<M; i++){",
            "\t\tlg2[i] = lg2[i/2] + 1;",
            "\t}",
            "",
            "}",
            "",
            "void make_table(int a[], int n){",
            "\tfor(int i=1; i<=n; i++){",
            "\t\ttable[i][0] = a[i];",
            "\t}",
            "\tfor(int j=1; j<K; j++){",
            "\t\tfor(int i=1; i+(1<<j)-1<=n; i++){",
            "\t\t\ttable[i][j] = min(table[i][j-1], table[i+(1<<(j-1))][j-1]);",
            "\t\t}",
            "\t}",
            "}",
            "",
            "int query(int L, int R){",
            "\tint len = lg2[R-L+1];",
            "\treturn min(table[L][len], table[R-(1<<len)+1][len]);",
            "}"
        ]
    },
    "String Hashing (double)": {
        "prefix": "hashing",
        "body": [
            "ll bigmod(ll x, ll p, ll md){",
            "\tll res = 1;",
            "\twhile(p){",
            "\t\tif(p & 1) res = res * x % md;",
            "\t\tx = x * x % md;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "ll modinv(ll x, ll md){",
            "\treturn bigmod(x, md-2, md);",
            "}",
            "",
            "namespace Hash{",
            "",
            "\tll pw[M][2];",
            "\tll invpw[M][2];",
            "\tconst int pr[] = {37, 53};",
            "\tconst int md[] = {(int)1e9+7, (int)1e9+9};",
            "",
            "",
            "\tvoid precalc(){",
            "",
            "\t\tpw[0][0] = pw[0][1] = 1;",
            "",
            "\t\tfor(int i=1; i<M; i++){",
            "\t\t\tpw[i][0] = pw[i-1][0] * pr[0] % md[0];",
            "\t\t\tpw[i][1] = pw[i-1][1] * pr[1] % md[1];",
            "\t\t}",
            "",
            "\t\tinvpw[M-1][0] = modinv(pw[M-1][0], md[0]);",
            "\t\tinvpw[M-1][1] = modinv(pw[M-1][1], md[1]);",
            "",
            "\t\tfor(int i=M-2; i>=0; i--){",
            "\t\t\tinvpw[i][0] = invpw[i+1][0] * pr[0] % md[0];",
            "\t\t\tinvpw[i][1] = invpw[i+1][1] * pr[1] % md[1];",
            "\t\t}",
            "\t}",
            "",
            "\tpii get_hash(const string &s){",
            "\t\tpii ret = {0, 0};",
            "\t\tfor(int i=0; i<s.size(); i++){",
            "\t\t\tret.first += (s[i]-'a'+1)*pw[i][0] % md[0];",
            "\t\t\tret.second += (s[i]-'a'+1)*pw[i][1] % md[1];",
            "\t\t\tret.first %= md[0];",
            "\t\t\tret.second %= md[1];",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tvoid prefix(const string &s, pii *H){",
            "\t\tH[0] = {0, 0};",
            "\t\tfor(int i=1; i<=s.size(); i++){",
            "\t\t\tH[i].first = H[i-1].first + (s[i-1]-'a'+1)*pw[i-1][0] % md[0];",
            "\t\t\tH[i].second = H[i-1].second + (s[i-1]-'a'+1)*pw[i-1][1] % md[1];",
            "\t\t\tH[i].first %= md[0];",
            "\t\t\tH[i].second %= md[1];",
            "\t\t}",
            "\t}",
            "",
            "\tvoid reverse_prefix(const string &s, pii *H){",
            "\t\tint n = s.size();",
            "\t\tfor(int i=1; i<=s.size(); i++){",
            "\t\t\tH[i].first = H[i-1].first + (s[i-1]-'a'+1)*pw[n-i][0] % md[0];",
            "\t\t\tH[i].second = H[i-1].second + (s[i-1]-'a'+1)*pw[n-i][1] % md[1];",
            "\t\t\tH[i].first %= md[0];",
            "\t\t\tH[i].second %= md[1];",
            "\t\t}",
            "\t}",
            "",
            "\tpii range_hash(int L, int R, pii H[]){",
            "\t\tpii ret;",
            "\t\tret.first = (H[R].first - H[L-1].first + md[0]) % md[0];",
            "\t\tret.second = (H[R].second - H[L-1].second + md[1]) % md[1];",
            "\t\tret.first = ret.first * invpw[L-1][0] % md[0];",
            "\t\tret.second = ret.second * invpw[L-1][1] % md[1];",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tpii reverse_hash(int L, int R, pii H[], int n){",
            "\t\tpii ret;",
            "\t\tret.first = (H[R].first - H[L-1].first + md[0]) % md[0];",
            "\t\tret.second = (H[R].second - H[L-1].second + md[1]) % md[1];",
            "\t\tret.first = ret.first * invpw[n-R][0] % md[0];",
            "\t\tret.second = ret.second * invpw[n-R][1] % md[1];",
            "\t\treturn ret;",
            "\t}",
            "",
            "}",
            ""
        ]
    },
    "Suffix Array": {
        "prefix": "suffix array",
        "body": [
            "vector<int>sort_cyclic_shifts(const string &s){",
            "\tconst int alphabet = 256;",
            "\tint n = s.size();",
            "",
            "\tvector<int>p(n), c(n), cnt(max(alphabet, n), 0);",
            "",
            "\tfor(int i=0; i<n; i++) cnt[s[i]]++;",
            "\tfor(int i=1; i<alphabet; i++) cnt[i] += cnt[i-1];",
            "\tfor(int i=0; i<n; i++){",
            "\t\tp[--cnt[s[i]]] = i;",
            "\t}",
            "",
            "\tc[p[0]] = 0;",
            "\tint classes = 1;",
            "\tfor(int i=1; i<n; i++){",
            "\t\tif(s[p[i]] != s[p[i-1]]) classes++;",
            "\t\tc[p[i]] = classes - 1;",
            "\t}",
            "",
            "\tvector<int>pn(n), cn(n);",
            "\tfor(int h=0; (1<<h)<n; h++){",
            "\t\tfor(int i=0; i<n; i++){",
            "\t\t\tpn[i] = p[i] - (1 << h);",
            "\t\t\tif(pn[i] < 0) pn[i] += n;",
            "\t\t}",
            "\t\tfor(int i=0; i<classes; i++) cnt[i] = 0;",
            "\t\tfor(int i=0; i<n; i++) cnt[c[pn[i]]]++;",
            "\t\tfor(int i=1; i<classes; i++) cnt[i] += cnt[i-1];",
            "",
            "\t\tfor(int i=n-1; i>=0; i--){",
            "\t\t\tp[--cnt[c[pn[i]]]] = pn[i];",
            "\t\t}",
            "\t\tcn[p[0]] = 0;",
            "\t\tclasses = 1;",
            "\t\tfor(int i=1; i<n; i++){",
            "\t\t\tpii cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};",
            "\t\t\tpii prev = {c[p[i-1]], c[(p[i-1] + (1 << h)) % n]};",
            "\t\t\tif(cur != prev) classes++;",
            "\t\t\tcn[p[i]] = classes - 1;",
            "\t\t}",
            "\t\tc.swap(cn);",
            "\t}",
            "\treturn p;",
            "",
            "}",
            "",
            "vector<int>suffix_array(string s){",
            "\ts += \"\\$\";",
            "\tvector<int>sorted_shifts = sort_cyclic_shifts(s);",
            "\tsorted_shifts.erase(sorted_shifts.begin());",
            "\treturn sorted_shifts;",
            "}",
            "",
            "vector<int>get_lcp(string const&s, vector<int>const& p){",
            "\tint n = s.size();",
            "\tvector<int>Rank(n, 0);",
            "\tfor(int i=0; i<n; i++){",
            "\t\tRank[p[i]] = i;",
            "\t}",
            "\tint k = 0;",
            "\tvector<int>lcp(n-1, 0);",
            "\tfor(int i=0; i<n; i++){",
            "\t\tif(Rank[i] == n-1){",
            "\t\t\tk = 0;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tint j = p[Rank[i] + 1];",
            "\t\twhile(i+k<n and j+k<n and s[i+k] == s[j+k]) k++;",
            "\t\tlcp[Rank[i]] = k;",
            "\t\tif(k) k--;",
            "\t}",
            "\treturn lcp;",
            "}"
        ]
    },
    "Topological Sorting": {
        "prefix": "toposort",
        "body": [
            "vector<int>g[M], topo;",
            "int vis[M];",
            "",
            "void dfs(int u){",
            "",
            "\tvis[u] = 1;",
            "",
            "\tfor(int v : g[u]){",
            "\t\tif(vis[v] == 1){",
            "\t\t\t//cycle found, topological ordering doesn't exist",
            "\t\t}",
            "\t\tif(!vis[v]) dfs(v);",
            "\t}",
            "",
            "\tvis[u] = 2;",
            "\ttopo.push_back(u);",
            "",
            "}",
            "",
            "void topo_sort(int n){",
            "",
            "\tfor(int i=1; i<=n; i++){",
            "\t\tif(!vis[i]) dfs(i);",
            "\t}",
            "\treverse(topo.begin(), topo.end());",
            "}"
        ]
    },
    "Trie": {
        "prefix": "trie",
        "body": [
            "int trie[N][K], word[N], cnt[N], sz;",
            "",
            "void Insert(string s){",
            "\tint node = 0;",
            "",
            "\tfor(int i=0; i<s.size(); i++){",
            "\t\tint c = s[i]-'a';",
            "\t\tif(!trie[node][c]){",
            "\t\t\ttrie[node][c] = ++sz;",
            "\t\t}",
            "\t\tnode = trie[node][c];",
            "\t\tcnt[node]++;",
            "\t}",
            "\tword[node]++;",
            "}",
            "",
            "bool Search(string s){",
            "\tint node = 0;",
            "",
            "\tfor(int i=0; i<s.size(); i++){",
            "\t\tint c = s[i]-'a';",
            "\t\tif(!trie[node][c]) return false;",
            "\t\tnode = trie[node][c];",
            "\t}",
            "",
            "\treturn (word[node] > 0);",
            "}",
            "",
            "void Delete(string s){",
            "\tint node = 0;",
            "\tvector<int>v(1, 0);",
            "",
            "\tfor(int i=0; i<s.size(); i++){",
            "\t\tint c = s[i]-'a';",
            "\t\tnode = trie[node][c];",
            "\t\tcnt[node]--;",
            "\t\tv.push_back(node);",
            "\t}",
            "",
            "\tword[node]--;",
            "",
            "\tfor(int i=1; i<v.size(); i++){",
            "\t\tint c = s[i-1]-'a';",
            "\t\tif(!cnt[v[i]]){",
            "\t\t\ttrie[v[i-1]][c] = 0;",
            "\t\t}",
            "\t}",
            "}",
            ""
        ]
    },
    "XOR basis": {
        "prefix": "basis",
        "body": [
            "/*",
            "consider numbers binary forms as vectors and XOR operation as addition (modulo 2)",
            "this basis represents all possible linear combinations (in this case, XOR subsets) of a given array",
            "*/",
            "",
            "ll basis[K];",
            "int sz;",
            "",
            "void insertVector(ll mask){",
            "\tfor(int i=0; i<K; i++){",
            "\t\tif(~mask >> i & 1) continue;",
            "\t\tif(!basis[i]){",
            "\t\t\tbasis[i] = mask;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tmask ^= basis[i];",
            "\t}",
            "}"
        ]
    },
    "Z-function": {
        "prefix": "z function",
        "body": [
            "vector<int>z_function(string s){",
            "",
            "\tint n = s.size(), l = 0, r = 0;",
            "\tvector<int>z(n, 0);",
            "",
            "\tfor(int i=1; i<n; i++){",
            "\t\tif(i<=r) z[i] = min(r-i+1, z[i-l]);",
            "\t\twhile(i+z[i] < n and s[z[i]] == s[i+z[i]]) z[i]++;",
            "\t\tif(i+z[i]-1 > r) l = i, r = i+z[i]-1;",
            "\t}",
            "",
            "\treturn z;",
            "",
            "}"
        ]
    },
    "Mo's Algorithm": {
        "prefix": "mo",
        "body": [
            "const int B = 450; //define B close to sqrt(n)",
            "",
            "void add(int idx){",
            "",
            "} ",
            "void remove(int idx){",
            "",
            "}",
            "ll get_answer(){",
            "",
            "}",
            "",
            "struct query{",
            "\tint l, r, idx;",
            "\tquery(){};",
            "\tquery(int _l, int _r, int _idx) : l(_l), r(_r), idx(_idx){};",
            "\tbool operator <(const query &other){",
            "\t\tif(l/B == other.l/B){",
            "\t\t\tif((l/B) & 1) return r > other.r;",
            "\t\t\telse return other.r > r;",
            "\t\t}",
            "\t\treturn l < other.l;",
            "\t}",
            "};",
            " ",
            "vector<ll>mo(vector<query>queries){",
            "\t",
            "\tvector<ll>answers(queries.size());",
            "\tsort(queries.begin(), queries.end());",
            " ",
            "\tint cur_l = 1, cur_r = 0;",
            " ",
            "\tfor(auto q : queries){",
            "\t\twhile(cur_l > q.l){",
            "\t\t\tcur_l--;",
            "\t\t\tadd(cur_l);",
            "\t\t}",
            "\t\twhile(cur_r < q.r){",
            "\t\t\tcur_r++;",
            "\t\t\tadd(cur_r);",
            "\t\t}",
            "\t\twhile(cur_l < q.l){",
            "\t\t\tremove(cur_l);",
            "\t\t\tcur_l++;",
            "\t\t}",
            "\t\twhile(cur_r > q.r){",
            "\t\t\tremove(cur_r);",
            "\t\t\tcur_r--;",
            "\t\t}",
            "\t\tanswers[q.idx] = get_answer();",
            "\t}",
            "",
            "\treturn answers;",
            " ",
            "}"
        ]
    },
    "Subtree Range Processing": {
        "prefix": "subtree range processing",
        "body": [
            "int tin[M], tout[M], timer;",
            "vector<int>times(1, 0);",
            "vector<int>order(1, 0);",
            "int pos[M];",
            "",
            "void dfs(int u, int par=0){",
            "",
            "\ttin[u] = ++timer;",
            "\tpos[u] = order.size();",
            "\ttimes.push_back(tin[u]);",
            "\torder.push_back(u);",
            "",
            "\tfor(int v : g[u]){",
            "\t\tif(v != par){",
            "\t\t\tdfs(v, u);",
            "\t\t}",
            "\t}",
            "",
            "\ttout[u] = ++timer;",
            "}",
            "",
            "void preprocess(int root, int n){ //run this first",
            "\tfor(int i=0; i<=n; i++) tin[i] = tout[i] = pos[i] = 0;",
            "\ttimes.assign(1, 0);",
            "\torder.assign(1, 0);",
            "\tdfs(root);",
            "}",
            "",
            "pii subtreeRange(int u){",
            "",
            "\tint L = lower_bound(times.begin(), times.end(), tin[u]) - times.begin();",
            "\tint R = lower_bound(times.begin(), times.end(), tout[u]) - times.begin();",
            "\treturn {L, R-1};",
            "",
            "}"
        ]
    }


}
